import{_ as e,c as o,o as i,ag as t}from"./chunks/framework.B-XtCDNB.js";const a="/assets/%E7%BB%84%E4%BB%B6.Bhhi6bUg.png",u="/assets/%E6%9E%B6%E6%9E%84.D0uryrHB.png",r="/assets/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0.Xs3e77SO.png",s="/assets/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B02.Ccb35Dx0.png",m=JSON.parse('{"title":"kubernetes","description":"","frontmatter":{},"headers":[],"relativePath":"DevOps/Kubernets概念.md","filePath":"DevOps/Kubernets概念.md"}'),p={name:"DevOps/Kubernets概念.md"};function n(c,l,d,b,k,q){return i(),o("div",null,[...l[0]||(l[0]=[t('<h1 id="kubernetes" tabindex="-1">kubernetes <a class="header-anchor" href="#kubernetes" aria-label="Permalink to &quot;kubernetes&quot;">​</a></h1><p>是管理云平台，多个主机的容器化应用：</p><ul><li>自我修复：一旦某一个容器崩溃，能够在 1 秒中左右迅速启动新的容器</li><li>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li>服务发现：服务可以通过自动发现的形式找到它所依赖的服务</li><li>负载均衡：如果一个服务起动了多个容器，能够自动实现请求的负载均衡</li><li>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li>存储编排：可以根据容器自身的需求自动创建存储卷</li></ul><h2 id="应用部署方式演变" tabindex="-1">应用部署方式演变 <a class="header-anchor" href="#应用部署方式演变" aria-label="Permalink to &quot;应用部署方式演变&quot;">​</a></h2><p>在部署应用程序的方式上，主要经历了三个时代：</p><ul><li><p>传统部署：互联网早期，会直接将应用程序部署在物理机上</p><ul><li>优点：简单，不需要其它技术的参与</li><li>缺点：不能为应用程序定义资源使用边界，很难合理地分配计算资源，而且程序之间容易产生影响</li></ul></li><li><p>虚拟化部署：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境</p><ul><li>优点：程序环境不会相互产生影响，提供了一定程度的安全性</li><li>缺点：增加了操作系统，浪费了部分资源</li></ul></li><li><p>容器化部署：与虚拟化类似，但是共享了操作系统</p><ul><li>优点： <ol><li>可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等</li><li>运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦</li><li>容器化的应用程序可以跨云服务商、跨 Linux 操作系统发行版进行部署</li></ol></li></ul></li></ul><h2 id="容器化部署方式给带来很多的便利-但是也会出现一些问题-比如说" tabindex="-1">容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说： <a class="header-anchor" href="#容器化部署方式给带来很多的便利-但是也会出现一些问题-比如说" aria-label="Permalink to &quot;容器化部署方式给带来很多的便利，但是也会出现一些问题，比如说：&quot;">​</a></h2><ul><li>一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器</li><li>当并发访问量变大的时候，怎么样做到横向扩展容器数量</li></ul><h2 id="这些容器管理的问题统称为容器编排问题-为了解决这些容器编排问题-就产生了一些容器编排的软件" tabindex="-1">这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件： <a class="header-anchor" href="#这些容器管理的问题统称为容器编排问题-为了解决这些容器编排问题-就产生了一些容器编排的软件" aria-label="Permalink to &quot;这些容器管理的问题统称为容器编排问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：&quot;">​</a></h2><ul><li>Swarm：Docker 自己的容器编排工具</li><li>Mesos：Apache 的一个资源统一管控的工具，需要和 Marathon 结合使用</li><li>Kubernetes：Google 开源的的容器编排工具</li></ul><h1 id="kubernetes-组件" tabindex="-1">Kubernetes 组件 <a class="header-anchor" href="#kubernetes-组件" aria-label="Permalink to &quot;Kubernetes 组件&quot;">​</a></h1><blockquote><p>通过控制台 kubectl(主)或 Dashboard；找到 Api-server 做对应的操作；</p></blockquote><h2 id="master" tabindex="-1">Master <a class="header-anchor" href="#master" aria-label="Permalink to &quot;Master&quot;">​</a></h2><blockquote><p>集群的控制平面，负责集群的决策 ( 管理 ) 包含了一些核心组件，负责集群的管理和控制；可以部署在多个节点上，提高可用性 核心交互通过 api-server</p></blockquote><ul><li>kube-ApiServer : 资源操作的唯一入口，接收用户输入的命令，提供认证、授权、API 注册和发现等机制</li><li>kube-ControllerManager : 核心集群控制器，针对 k8s 的各种资源进行管理，负责维护集群的状态，比如故障检测、自动扩展、滚动更新、服务发现等</li><li>cloud-ControllerManager : 云平台专用控制器，专注于将 kubernetes 资源和云原生资源（负载均衡器、存储、虚拟机等）绑定，并自动化云平台操作</li><li>kube-Scheduler : 负责集群资源调度，按照预定的调度策略将 Pod 调度到相应的 node 节点上</li><li>Etcd ：负责存储集群中各种资源对象的信息；相当于数据库，键值类型存储的分布式数据库，提供基于 Raft 算法实现自主的集群高可用；老版本基于内存，新版本持久化存储磁盘</li></ul><h2 id="node" tabindex="-1">node <a class="header-anchor" href="#node" aria-label="Permalink to &quot;node&quot;">​</a></h2><blockquote><p>集群的数据平面，负责为容器提供运行环境 ( 干活 ) 最少会有 3 个东西，kubelet、kube-proxy 和 docker。 1 台服务器是 1 个节点 Node,肯定有 1 个 Kubelet，可能有多个 kube-proxy，可能有多个 pod；每个 pod 至少有一个容器，每个 pod 可以有多个容器。</p></blockquote><ul><li><p>Kubelet : 负责维护容器的生命周期，即通过控制 docker，来创建、更新、销毁容器</p></li><li><p>KubeProxy : 负责提供集群内部的服务发现和负载均衡</p></li><li><p>Container-runtime : 例如 Docker、containerd、CRI-O;负责节点上容器的各种操作</p></li></ul><h2 id="附加组件" tabindex="-1">附加组件 <a class="header-anchor" href="#附加组件" aria-label="Permalink to &quot;附加组件&quot;">​</a></h2><blockquote><p>附加组件可以增强 Kubernetes 的功能</p></blockquote><ul><li>kube-dns : 负责为整个集群提供 DNS 服务</li><li>Ingress Controller : 为服务提供外网入口</li><li>Heapster/Prometheus : 用于集群的监控</li><li>Dashboard : 提供了一个简单的 Web 界面</li><li>Federation : 可以跨多个 Kubernetes 集群进行资源管理</li><li>Fluentd-elasticsearch : 提供集群日志的收集、存储和查询</li></ul><p><img src="'+a+'" alt="alt text"></p><h1 id="分层架构" tabindex="-1">分层架构 <a class="header-anchor" href="#分层架构" aria-label="Permalink to &quot;分层架构&quot;">​</a></h1><ul><li>生态系统 <blockquote><p>顶层为生态系统，例如 ingress、kubedns、Prometheus、Dashboard 等；都是基于 k8s 构建的；</p></blockquote></li><li>接口层 <blockquote><p>所有应用都要调用 k8s 接口</p></blockquote></li><li>管理层 <blockquote><p>调接口后进入管理层，自动化管理相关应用；比如基础设置、网络、自动化的调度、权限控制</p></blockquote></li><li>应用层 <blockquote><p>应用层做部署操作，具体是 Pod 相关；无状态应用、有状态应用、批处理任务、集群应用和路由（服务发现、DNS 解析）</p></blockquote></li><li>核心层 <blockquote><p>最底层功能的实现</p></blockquote></li></ul><blockquote><p>下面，以部署一个 nginx 服务来说明 kubernetes 系统各个组件调用关系：</p></blockquote><blockquote><ol><li>首先要明确，一旦 kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到 etcd 数据库中</li><li>一个 nginx 服务的安装请求会首先被发送到 master 节点的 apiServer 组件</li><li>apiServer 组件会调用 scheduler 组件来决定到底应该把这个服务安装到哪个 node 节点上</li><li>在此时，它会从 etcd 中读取各个 node 节点的信息，然后按照一定的算法进行选择，并将结果告知 apiServer</li><li>apiServer 调用 controller-manager 去调度 Node 节点安装 nginx 服务</li><li>kubelet 接收到指令后，会通知 docker，然后由 docker 来启动一个 nginx 的 pod</li><li>pod 是 kubernetes 的最小操作单元，容器必须跑在 pod 中至此，</li><li>一个 nginx 服务就运行了，如果需要访问 nginx，就需要通过 kube-proxy 来对 pod 产生访问的代理。这样，外界用户就可以访问集群中的 nginx 服务了</li></ol></blockquote><p><img src="'+u+'" alt="alt text"></p><h1 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h1><ul><li>Master：集群控制节点，每个集群需要至少一个 master 节点负责集群的管控</li><li>Node：工作负载节点，由 master 分配容器到这些 node 工作节点上，然后 node 节点上的 docker 负责容器的运行</li><li>Pod：kubernetes 的最小控制单元，容器都是运行在 pod 中的，一个 pod 中可以有 1 个或者多个容器</li><li>Controller：控制器，通过它来实现对 pod 的管理，比如启动 pod、停止 pod、伸缩 pod 的数量等等</li><li>Service：pod 对外服务的统一入口，下面可以维护者同一类的多个 pod</li><li>Label：标签，用于对 pod 进行分类，同一类 pod 会拥有相同的标签</li><li>NameSpace：命名空间，用来隔离 pod 的运行环境</li></ul><h2 id="资源的分类" tabindex="-1">资源的分类 <a class="header-anchor" href="#资源的分类" aria-label="Permalink to &quot;资源的分类&quot;">​</a></h2><h3 id="元数据型" tabindex="-1">元数据型 <a class="header-anchor" href="#元数据型" aria-label="Permalink to &quot;元数据型&quot;">​</a></h3><blockquote><p>存储配置、策略、权限等元数据，通常用于支撑其他资源的运行； 作用域：集群级别或命名空间级</p></blockquote><ul><li>Horizontal Pod Autoscaler(HPA): Pod 水平自动扩容，可以根据 CPU 的使用率或自定义指标自动进行扩容；控制器每隔 30s 采集一次数据，并根据策略进行扩容；</li><li>PodTemplate: Pod 模板</li><li>LimitRange: 定义 Pod 或容器的资源限制（如 CPU、内存）</li></ul><h3 id="集群级" tabindex="-1">集群级 <a class="header-anchor" href="#集群级" aria-label="Permalink to &quot;集群级&quot;">​</a></h3><blockquote><p>管理集群基础设施或全局策略 作用域：全局有效，不属于任何命名空间</p></blockquote><ul><li>Node: 节点，不像其他资源(Pod 和 Namespace),本质不是 k8s 创建的。是 1 个服务器,k8s 只会去检查子是否有这个 Node，如果检查失败，不会往上调度 Pod</li><li>Namespace: 命名空间，资源本身是集群级；</li><li>ClusterRole: 集群级别的角色，集群级别的资源(Node/PV/Pod/API 等)</li><li>ClusterRoleBinding: 集群级别的角色绑定，仅用于 ClusterRole</li></ul><h3 id="命名空间级" tabindex="-1">命名空间级 <a class="header-anchor" href="#命名空间级" aria-label="Permalink to &quot;命名空间级&quot;">​</a></h3><blockquote><p>作用域：属于某个命名空间，仅在该命名空间内生效 通常标识应用的工作负载、网络或存储请求</p></blockquote><ul><li><p>工作负载型</p><ul><li><p>Pod</p><blockquote><p>最小调度单元,一个 Pod 包含了应用程序容器、存储资源、1 个唯一的网络 IP 地址、一些确定容器该运行的选项；代表了 k8s 集群中运行的一个实例看可能有多个容器 为什么需要多个容器：</p><ol><li>实现容器与容器之间，网络共享</li><li>实现容器与容器之间，数据共享</li></ol><p>如何解决： Pod 底层有 1 个 pause 容器，用来共享网络和存储 副本和控制器都是 Pod 对象</p></blockquote><ul><li>副本 <ul><li>replicas <blockquote><p>副本数，保证 Pod 的数量始终为期望的数量；</p></blockquote></li></ul></li><li>控制器 <blockquote><p>控制器是用来管理 Pod 的，保证 Pod 的数量始终为期望的数量；</p></blockquote><ul><li>适用无状态服务 <blockquote><p>nginx、tomcat 等集群服务时使用</p></blockquote><ul><li>ReplicationController（RC） <blockquote><p>动态更新副本数，被 RS 替代，因为不支持 Label 和 Selector 选择器；</p></blockquote></li><li>ReplicaSet（RS）&gt; Label 和 Selector <blockquote><p>动态更新 Pod 副本数，可以选择针对那些 Pod 生效，但只有扩容和缩容，被 Deployment 替代</p></blockquote></li><li>Deployment <blockquote><p>动态创建 RS 和 Pod，滚动升级和回滚，平滑扩容和缩容；暂停和恢复 Deployment</p></blockquote></li></ul></li><li>适用有状态服务 <blockquote><p>Redis/MySQL/Elasticsearch 等集群服务时使用</p></blockquote><ul><li>StatefulSet <blockquote><p>为每个 Pod 的 DNS 格式为 <strong>statefulSetName-{0...N-1}.serviceName.namespace.svc.cluster.local</strong></p><ol><li>serviceName 为 Headless Service 的名称</li><li>0.N-1 表示 Pod 的序号，从 0 开始</li><li>statefulSetName 为 StatefulSet 的名称 4. namespace 为命名空间；HeadlessServicehe StatefulSet 必须同一个命名空间</li><li>svc.cluster.local 为集群的域名</li></ol></blockquote><ul><li>特点 <ol><li>稳定的持久性存储</li><li>稳定的网络标识</li><li>有序部署和有序扩展</li><li>有序收缩、有序删除</li></ol></li><li>组成 <ol><li>Headless Service：定义 DNS domain</li><li>volumeClaimTemplate：定义存储卷</li></ol></li><li>注意事项 <ol><li>kubernetes1.5 版本以上才支持</li><li>所有 Pod 的 Volume 必须使用 PersistentVolume 或者是管理员实现创建好</li><li>为了保证数据安全，删除 StatefulSet 时不会删除 volume</li><li>StatefulSet 需要一个 Headless Service 来定义 DNS domain 需要在 StatefulSet 前创建好</li></ol></li></ul></li></ul></li><li>守护进程 <blockquote><p>在每个节点上运行一个 Pod，如日志收集、监控等集群服务时使用；搭配其他无状态和有状态服务一起使用</p><ol><li>日志收集：fluentd、logstash、filebeat 等日志收集工具；</li><li>系统监控：Prometheus Node Exporter、Collectdd、Ganglia 等监控工具；</li><li>系统程序：kube-proxy、kubedns、glusterd、ceph 等</li></ol></blockquote><ul><li>DaemonSet</li></ul></li><li>任务/定时任务 <blockquote><p>一次性任务、定时任务集群服务时使用</p></blockquote><ul><li>Job：一次性运行的任务（脚本、下载数据、数据初始化等）</li><li>CronJob：定时任务</li></ul></li></ul></li></ul><blockquote><p>前三种会持续执行，最后一种任务属于运行完就结束。</p></blockquote></li></ul></li><li><p>服务发现</p><blockquote><p><img src="'+r+'" alt="alt text"></p></blockquote><blockquote><p><img src="'+s+'" alt="alt text"></p></blockquote><ul><li><p>Service：实现东西流量；集群内部的网络通信，内部跨节点通信，Pod 与 Pod 通信；</p><blockquote><p>上图图 2:service 提供了内部访问</p></blockquote></li><li><p>Ingress：实现南北流量；集群外部的网络通信，Pod 与外界通信；</p><blockquote><p>Ingress-nginx 实现反向代理和负载均衡(7 层)，对外暴露服务； 上图图 2:ingress 提供了外部访问</p></blockquote></li></ul></li><li><p>配置与存储</p><ul><li>Volume：存储卷，共享 Pod 中容器使用的数据，用于持久化数据； <ul><li>PV：持久卷，存储卷的抽象，可以是磁盘、网络文件系统等；</li><li>PVC：持久卷声明，对存储资源的请求；</li></ul></li><li>CSI：标准接口，用于实现自定义存储卷；</li></ul></li><li><p>特殊类型存储</p><ul><li>ConfigMap：key/value 配置信息，用于存储配置信息；pod 的容器可以通过环境变量、命令行参数等方式使用；</li><li>Secret：比 ConfigMap 更安全，用于存储敏感信息；pod 的容器可以通过环境变量、命令行参数等方式使用；有 3 种类型： <blockquote><ol><li>Service Account</li><li>Opaque:Base64 编码的 secret</li><li>Kubernetes.io/dockerconfigjson；</li></ol></blockquote></li><li>Downward API：把 Pod 信息共享到容器中；通过环境变量、volume 挂在等方式使用；</li></ul></li><li><p>其他</p><ul><li>Role：作用于某个命名空间；适用于命名空间内资源：pod</li><li>RoleBinding：作用于某个命名空间；绑定对象 Role 或 ClusterRole</li></ul></li></ul>',39)])])}const P=e(p,[["render",n]]);export{m as __pageData,P as default};
