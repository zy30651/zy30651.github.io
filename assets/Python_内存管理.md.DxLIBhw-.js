import{_ as s,c as a,o as t,ag as n}from"./chunks/framework.B-XtCDNB.js";const g=JSON.parse('{"title":"内存管理","description":"","frontmatter":{},"headers":[],"relativePath":"Python/内存管理.md","filePath":"Python/内存管理.md"}'),h={name:"Python/内存管理.md"};function l(e,i,p,r,k,o){return t(),a("div",null,[...i[0]||(i[0]=[n(`<h1 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h1><h2 id="引用计数" tabindex="-1">引用计数 <a class="header-anchor" href="#引用计数" aria-label="Permalink to &quot;引用计数&quot;">​</a></h2><p>Python 中每个对象都有一个引用计数器，用于记录有多少个变量引用了该对象。</p><p>当一个 Python 对象被引用时其引用计数增加 1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于 0 时对象被删除。</p><p>缺点：无法解决多个对象循环引用问题</p><p>优化：</p><ol><li><p>可以使用del删除对象</p></li><li><p>可以使用弱引用 weakref</p></li><li><p>使用生成器和迭代器；当需要时才生成数据</p><div class="language-py vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用生成器表达式： 不会一次性生成所有数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gen </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 使用列表推导式：会一次性生成所有数据</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">lst </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">in</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span></code></pre></div></li></ol><h2 id="垃圾回收" tabindex="-1">垃圾回收 <a class="header-anchor" href="#垃圾回收" aria-label="Permalink to &quot;垃圾回收&quot;">​</a></h2><p>一、标记-清除算法</p><p><strong>标记阶段</strong>：从根对象（如全局变量、栈上的变量等）开始遍历所有可达对象，并标记它们。</p><p><strong>清除阶段</strong>：遍历所有对象，将未标记的对象（即不可达对象）的内存释放。</p><p>二、分代回收</p><p>Python 的垃圾回收机制采用了分代回收策略，将对象分为不同的代，根据对象的存活时间进行不同频率的垃圾回收。</p><ul><li><strong>第 0 代</strong>：新创建的对象属于第 0 代，这一代的对象存活时间较短，垃圾回收频率较高。</li><li><strong>第 1 代</strong>：经过一次垃圾回收后仍然存活的对象会被移动到第 1 代，垃圾回收频率相对较低。</li><li><strong>第 2 代</strong>：经过多次垃圾回收后仍然存活的对象会被移动到第 2 代，垃圾回收频率最低</li></ul><h2 id="内存池" tabindex="-1">内存池 <a class="header-anchor" href="#内存池" aria-label="Permalink to &quot;内存池&quot;">​</a></h2><h5 id="一-小对象内存池" tabindex="-1">（一）小对象内存池 <a class="header-anchor" href="#一-小对象内存池" aria-label="Permalink to &quot;（一）小对象内存池&quot;">​</a></h5><p>Python 为了减少频繁的内存分配和释放带来的开销，引入了小对象内存池机制。对于大小在一定范围内（通常是 1 - 512 字节）的小对象，Python 会使用内存池进行管理。</p><p>当需要创建小对象时，会首先从内存池中分配内存；当对象被释放时，其占用的内存会被放回内存池，而不是直接归还给操作系统。</p><h5 id="二-内存池的工作原理" tabindex="-1">（二）内存池的工作原理 <a class="header-anchor" href="#二-内存池的工作原理" aria-label="Permalink to &quot;（二）内存池的工作原理&quot;">​</a></h5><p>内存池分为多个层级，每个层级管理不同大小的内存块。当请求分配内存时，会根据对象的大小选择合适的层级进行分配。</p>`,20)])])}const E=s(h,[["render",l]]);export{g as __pageData,E as default};
